%% example.tex % Jeremy Singer % 16 Oct 12

\documentclass{mpaper}

\begin{document}

\title{Is Technical Debt Real?}
\author{Ovidiu Popoviciu}
\matricnum{2036725p}


\maketitle


\begin{abstract}
Simple abstract describing the problem, motivation, experimental design,
evaluation result and relevance.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
\label{introduction}

\begin{enumerate}
  \item General description of the problem, motivation, relevance
  \item Contributions to state of the art 
  \item Research questions
  \item Section descriptions
\end{enumerate}

% The precise structure of an MSci paper is not mandated, but it should probably
% cover in detail the following aspects of the project. \begin{enumerate} \item
% General description of the problem, motivation, relevance \item Background
% information, possibly including a literature survey \item Description of
% approach taken to solve the problem, including high-level design and
% lower-level implementation details as appropriate \item Evaluation,
% qualitative or quantitative as appropriate \item Conclusion, including scope
% for future work \end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Background}
\label{background}

\begin{enumerate}
  \item literature review (a bit more compressed compared to proposal)
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Methodology}
\label{methodology}

In this paper, we present an approach for aggregating development team data
sources such as project management tools, version control logs and static
analysis results to produce a timeline of technical debt and work effort over
the evolution of a software product. Our motivation is to empirically find a
correlation between technical debt and the amount of work effort involved in
development of work items. In the absence of work tracking information,
aggregation of such data sources might provide a relatively accurate estimation
of the number of hours a developer has put in.

When developing our approach, we completed the following steps:
\begin{enumerate}
  \item Designing an initial data model.
  \item Selecting data candidates (projects) that satisfy specific criteria.
  \item Collecting data from issue tracker, version control logs and generating
  static analysis output.
  \item Processing and refining data for analysis. 
\end{enumerate}

Section \ref{experimental-design} dives into the data model while section
\ref{data-selection} describes the data candidates criteria and selected
projects. The data collection process is described in Section
\ref{data-collection} while the calculation of work effort and technical debt is
described in Section \ref{data-processing}.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsection{Experimental Design}
\label{experimental-design}

The initial step was to design a model of the aggregated data and to understand
what type of information each selected data source will provide. We consider the
following data sources relevant to the collection of data:

\begin{itemize}
  \item A \emph{Version Control System} is a system that manages changes to the
  source code. As work items are implemented, the system logs all changes made
  by the development team. The most popular version control tool is Git
  \emph{REFERENCE}. GitHub \emph{REFERENCE} and BitBucket \emph{REFERENCE} are
  hosting services for source code management.

  \item \emph{Project Management Tools} are software systems that help teams
  track, manage and collaborate on various types of units of work. A common
  example of a complex project management tool is Jira \emph{REFERENCE}. GitHub
  and BitBucket also provide an issue tracking tool with each code repository,
  although they do not provide such extensive features as Jira.
  
  \item \emph{Static Analysis Tools} are tools that analyse the source code to
  check for quality issues, security flaws and adherence to industry
  standards.There are many examples of static analysis tools: SonarQube,
  Spotbugs (formerly Findbugs), CAST, Sonargraph, etc.

\end{itemize}

All the data sources contain detailed information related to the set of changes
that the source code has suffered, the requirement that the developer is working
on and the possible quality issues she will encounter during implementation. In
many cases, these systems have been implemented by different producers and thus
are generally ``separated''. Therefore, data must be collected from each system,
in isolation. However, forms of ``light integrations'' exists for development
productivity purposes such as linking of work items to change-sets by specifying
the work item ID in the change-set description message. Such provide guidance on
how many change-sets the source code has suffered during the implementation of a
work item.

The centralised data model, presented in Figure \emph{FIGURE}, highlights the
integration of version control logs, issue tracker data and static analysis
output. The next few sections highlight the data model of each source in
isolation.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection*{Version Control}
\label{version-control}

The version control system keeps track and logs all changes that a source code
has suffered over the evolution of the product. Such logs are indispensable due
to their metadata which provides information on the accomplished work.

Git \emph{REFERENCE} is a popular version control tool that tracks changes of
the source code using branches and commits. Projects are stored in a
``repository'' which contains at least one development line, called a
``branch''. The main development branch is commonly named the \emph{master}
branch. Branches contain a stream of small units of work, called ``commits'',
which are the snapshots of the source code at a particular point in time.
Additionally, each commit contains relevant metadata with the following fields:

\begin{itemize}
  \item \emph{Object ID} - is the identifier of the snapshot;
  \item \emph{Author} - the name (or username) of the developer that committed
  the change;
  \item \emph{Message} - a short description of the change-set;
  \item \emph{Timestamp} - the time when the commit was created;
  \item \emph{Diff} - the set of changes that the source code has suffered, when
  compared to the previous commit. 
\end{itemize}

If the system allows integrations with a project management tool, changes can be
directly linked to the appropriate work unit. The most common method is to
specify the work item ID in the message field of the commit ID. As a result, it
is simpler to find out which change-sets belong to a particular work item. 

For a project managed using Git, all the metadata can be easily retrieved and
snapshots can be accessed at any time. This makes Git a powerful tool in
studying the history of changes of a software product.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection*{Project Management}
\label{project-management}

Project management tools allows developers and project managers to keep track of
the work that must be accomplished and of the issues that have been reported by
the users of the software. 

Each work item is represented in the form of a \emph{ticket}, which is a report
of the work that needs to be completed. Depending on the workflow of the team,
tickets may go through various status transitions during their lifetime which
represent checkpoints of the work involved. A ticket may contain a lot of data,
including but not limited to:

\begin{itemize}
  \item \emph{ID} - the unique identifier of the work item in the project;
  \item \emph{Type} - the type of work e.g. Feature, Bug, Enhacement, etc.;
  \item \emph{Status} - the current status of the work e.g. Created, In
  development, In testing, Closed, etc.;
  \item \emph{Summary} - a brief description of the work;
  \item \emph{Description} - a longer, more detailed description of the work
  involved;
  \item \emph{Priority} - the importance of the work as considered by the team;
  \item \emph{Assignee} - the team member responsible for completing the work;
  \item \emph{Complexity} - measurement of how complex the work item is e.g.
  Story points;
  \item \emph{Comments} - a list of comments by other team members to promote
  discussion on the work;
  \item \emph{Timestamps} - the times when ticket was created, updated, closed
  and when it is due. 
\end{itemize}

Additionally, Jira tickets contain a field called \emph{Time Tracking} that
allows tracking of the estimated time to complete the work, time logged and time
left. Moreover, for Jira, the history of changes of a work item is available
through its API in a field called \emph{Transitions}. This metadata provides a
good idea of when development for a specific work has started or ended, by
analysing the changes of the status field over time. 

Although project management tools provide relevant work tracking information,
not all tools offer the same broad scope of work data. For example, the
integrated issue tracker within GitHub and BitBucket do not offer the same
features and functionality that Jira does. Additionally, many of the fields of
tickets might be non-existent. This poses a problem to the validity of the work
effort calculations, mentioned in section \ref{data-processing}. 

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection*{Static Analysis}
\label{static-analysis}

% intro
Static analysis tools provide an elegant method of analysing source code for
possible weaknesses and quality issues without a direct execution of the entire
product. Its applicability makes it a great tool for developers to analyse their
change-sets at any time of the implementation process.

% body
The output of static analysis tools are generally weaknesses and bugs that may
lead to vulnerabilities which are considered ``lowest level'' of technical debt.
Code debt is technical debt that developers have to encounter daily
\emph{REFERENCE}. There are many static analysis tools, many of which have been
reviewed \emph{REFERENCE}, \emph{REFERENCE}. 

Although static analysis tools provide an approximate measure of the quality of
the code base, there is a danger in associating technical debt with their
output. There are multiple types of technical debt present in the software
development environment \emph{REFERENCE}. For example, static analysis tools
cannot predict that the requirements gathering phase was not completed
appropriately and thus it might take more time for a team member to understand
the expectations of a work item, thus indirectly increasing effort. However, as
a simplifying assumption, in this paper we only consider code debt in the
calculation of a technical debt index. 

The output of a static analysis tool that we are interested in contains the
following fields:

\begin{itemize}
  \item \emph{ID} - a unique identifier of the quality issue;
  \item \emph{Priority} - a generic measure of severeness e.g. High, Medium,
  Low;
  \item \emph{Description} - a short description of the code violation;
  \item \emph{Location} - the location of the quality issue, represented by the
  file name and line number. 
\end{itemize}

This type of output gives a representation of the possible low-level weaknesses
that developers might introduce and encounter during the implementation process.
Additionally, by using the version control logs it is possible to track the
items that have been introduced or removed for each change-set as well as the
total amount of issues that a team member had to deal with.

Unfortunately, not all projects make use of a static analysis tool and therefore
such information might not be publicly available. As a result, we have decided
to execute static analysis on each revision of the main branch our candidate
projects. This allows a consistent data model of quality issues and fills in the
lack of static analysis data.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsection{Candidates selection}
\label{data-selection}

% intro
For the purpose of this experiment, we had to apply the data collection
processing phases on a set of software projects. These projects had to satisfy a
certain criteria to be included:

\begin{itemize}
  \item Use \emph{Git} as a version control tool due to its powerful features,
  applicability and popularity. Additionally, the project must be open-source to
  access the history of snapshots.
  \item Use a project management tool that is publicly accessible to retrieve
  work item data.
  \item Use \emph{Java} as the main programming language. This was a simplifying
  criteria to keep the data collection and processing consistent. Additionally,
  this aided our decision in selecting a single static analysis tool.
  \item The project should have a single main development branch, preferably the
  ``master'' branch. This relieves the data collection process of analysing
  multiple branches.
  \item The version control hosting system should integrate with the project
  management tool to highlight the commits that belong to a specific work item.
\end{itemize}

% body
Table \emph{TABLE} shows the selected open-source projects that have their data
collected and analysed as well as their size (LOC), version control and project
management tools. Out of the ten projects, we have only included five for
analysis of results due to an incomplete data collection process. This was a
result of:

\begin{itemize}
  \item Unavailable APIs for accessing project management tool.
  \item Non-existent static analysis output. This might be due to a ``Zero
  Bugs'' policy set by the development team.
  \item Failing build process for the majority of revisions. The build process
  was failing on too many revisions to provide any meaningful data.
\end{itemize}

% conclusion


% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsection{Data collection}
\label{data-collection}

Describe the data model and low level implementation details of the data
collection process.

\begin{enumerate}
  \item Discuss the data model with entities such as repository, commit, issue,
  bug, etc. 
  \item Discuss the data gathering process. What fields were gathered? What is
  the difference between Github issues and Jira issues?
  \item Mention data sources, tools, optimisations for data candidates
\end{enumerate}

% intro
In this case, some of the data sources are distributed and use different
underlying technologies whereas others must be generated if non existent. Data
is queried from these remote systems and aggregated into a single source of
truth.

% body

% conclusion
Furthermore, to understand the correlation between work effort and technical
debt we process the data further, as explained in Section \ref{data-processing}.


% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsection{Data processing}
\label{data-processing}

Describe the data processing implementation details for calculating technical
debt, work effort using both commits and tickets.

\begin{itemize}
  \item Calculation of work effort: using commit timestamps and ticket
  timestamps.
  \item Calculation of technical debt: added, removed, total pain.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Results}
\label{results}

Provide the results of the data processing step. Aggregate the data into tables
based on the repositories chosen and provide a couple of example graphs. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Discussion}
\label{discussion}

Discuss the results and limitations of the experiment.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsection{Threats to validity}
\label{validity}

Risks to the methods of extraction, calculation and aggregation of technical
debt, work effort, ticket complexity, etc.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Future Work}
\label{future-work}

Describe the items that could be improved and expand on the next steps within
this area of research.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion}
\label{conclusion}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{\bf Acknowledgments.} This is optional; it is a location for you to thank
people

\bibliographystyle{abbrv}
\bibliography{mdiss}

\end{document}